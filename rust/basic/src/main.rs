
// Linear List (线性表): 任意一对相邻的数据元素存在序偶关系，ai-1 成为ai的前驱，ai成为ai-1的后继
//    sequential list: 用一段连续的存储单元依次存储线性表的元素。
//    singly linked list: 用一组任意的存储单元放线性表的元素
//    双链表和循环链表
//    Stack: LFO(last in first out), Push/Pop, 有多重优先级的可以用多个stack来处理，比如 a+b*c
//    a,b,c 有顺序优先级，+* 有运算优先级，构建符号栈和数字栈来拆分优先级然后进行运算
//    Queue: FFO(first in first out), EnQueue/DeQueue
// Tree:
//    存储：双亲表，链表；
//    degree: 子树的个数称为该节点的度
//    前序/中序/后序遍历(traverse)：用Stack做访问处理，或者递归;
//    层序遍历：用队列做处理，将根节点入队，将根节点出队，将该节点的所有子节点入队，依次进行访问
//    树转换为二叉树：树中所有相领兄弟节点之间加一条线，树中每个节点只保留它与第一个孩子节点之间的连线；前序遍历树和二叉树等价，树的后序遍历等价于树的中序遍历；
//    森林转换为二叉树：将每棵树转换成二叉树，从第二棵树开始，依次把后一课二叉树的根节点作为前一棵二叉树根节点的右孩子；
//    树转换成的二叉树，其根节点无右子树，森林转换后的二叉树其根节点有右子树。
//    完全二叉树：对一棵具有n个节点的二叉树按层序编号，如果编号为i的节点与同样深度的满二叉树编号为i的节点位置完全相同。
//                堆是具有以下性质的二叉树：每个节点的值都小于或等于其左右孩子节点的值（小根堆）；或者每个节点的值都大于等于其左右孩子节点的值
//                堆可以用数组来存储，假设当前节点编号为k，堆中最后一个节点的编号为m，并且节点k的左右子树均是堆即r[k+1]~r[m]满足堆的条件
// Graph:
//    存储：邻接矩阵，用一个一维数组存顶点，用一个二维数组存边的信息连接为1，没有连接为0
//          邻接表，图的每个顶点v，将所有邻接于v的顶点链成一个单链表
//    Depth-first Traverse(深度优先遍历): 访问顶点v，然后从v的未访问的邻接点中选取一个顶点。
//    Breadth-first Traverse(广度优先遍历): 访问顶点v，依次访问v的各个未被访问的邻接点。
//
// Sort
//     插入排序：每次将一个待排序的记录按其关键码的大小插入到一个已经排好序的有序序列中，直到全部记录排好序。
//     交换排序：
//         bubble sort：两两比较相邻记录的关键码，如果反序则交换，直到没有反序的记录为止。
//         quick sort: 选一个轴值，将待排序记录分割成独立的两部分，左侧记录的关键码均小于或等于轴值，右侧记录的关键码均大于或等于轴值。
//
//    选择排序:
//        simple selection sort:  顺序遍历集合，查找最后一个小于当前节点的元素，进行交换，然后继续下一次查找
//        heap sort: 选出堆顶记录，然后将它从堆中移走，将剩余记录再调整成堆，取堆顶记录。在找出关键码最小记录的同时，也找出关键码较小的记录
//        归并排序:


fn main() {
    println!("Hello, world!");
}

fn sift(int r[], int k, int m) {
    let mut i = k; // j为i的左孩子
    let mut j = 2*i; // 一定是k节点的子树
    while( j <= m) {
        if (j<m && r[j]<r[j+1]) j++; // 比较i的左右孩子，j为较大者
        if (r[i]>r[j]) break; // 根节点已经大于左右孩子中的较大者
        else {
            r[i] <-> r[j]; // 将根节点与节点j交换
            i=j;
            j=2*i; // 被筛选节点位于原来节点j的位置
        }
    }
}

/**
 * 序列就是一个完全二叉树的顺序存储，则所有的叶子节点都已经是堆，所以只需要从第[n/2]个记录开始，执行筛选直到根节点
 * n/2 的原因是？
 */
fn heapSort(int r[], int n) {
    for(i=n/2; i>=1; i--)
        Sift(r,i,n);
    for(i=1;i<n; i++){
        r[1] <-> r[n-i+1];
        Sift(r,1,n-i);
    }
}

